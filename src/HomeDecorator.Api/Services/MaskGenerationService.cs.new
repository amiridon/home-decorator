using System;
using System.IO;
using System.Net.Http;
using System.Text;
using System.Text.Json;
using System.Threading.Tasks;
using System.Collections.Generic;
using Microsoft.Extensions.Caching.Memory;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.Logging;

namespace HomeDecorator.Api.Services;

/// <summary>
/// Service for generating masks to control which parts of an image can be edited.
/// Uses a segmentation approach where transparent areas are editable and opaque areas are preserved.
/// </summary>
public class MaskGenerationService
{
    private readonly ILogger<MaskGenerationService> _logger;
    private readonly HttpClient _httpClient;
    private readonly IConfiguration _configuration;
    private readonly IMemoryCache _cache;    // Categories of objects that should be considered "furniture" or "decorative elements" (editable)
    private static readonly HashSet<string> EditableCategories = new(StringComparer.OrdinalIgnoreCase)
    {
        "sofa", "couch", "chair", "table", "coffee table", "dining table", "desk", "bed", "lamp",
        "cabinet", "wardrobe", "dresser", "shelf", "bookshelf", "rug", "carpet", "curtain", "pillow",
        "cushion", "artwork", "painting", "picture", "mirror", "vase", "plant", "clock", "tv",
        "television", "appliance", "decor", "decoration", "furniture", "ornament", "accessory"
    };

    // Categories that should be considered "structural elements" (preserved)
    private static readonly HashSet<string> StructuralCategories = new(StringComparer.OrdinalIgnoreCase)
    {
        "wall", "ceiling", "floor", "beam", "column", "window", "door", "doorway", "staircase",
        "stairs", "banister", "railing", "fireplace", "chimney", "radiator", "molding", "trim",
        "baseboard", "crown molding", "electrical outlet", "switch", "vent", "hvac", "pipe",
        "structural", "architecture", "building", "room", "space"
    };

    // Categories for wall art and decorative elements (separate pass)
    private static readonly HashSet<string> WallArtCategories = new(StringComparer.OrdinalIgnoreCase)
    {
        "artwork", "painting", "picture", "photograph", "poster", "print", "canvas", "frame",
        "wall art", "wall decor", "hanging", "mounted"
    };

    // Confidence thresholds for automatic filtering
    private const float HighConfidenceThreshold = 0.8f;
    private const float MediumConfidenceThreshold = 0.6f;
    private const int OptimalSegmentationSize = 1024;public MaskGenerationService(
        ILogger<MaskGenerationService> logger,
        IConfiguration configuration,
        IMemoryCache memoryCache)
    {
        _logger = logger;
        _configuration = configuration;
        _httpClient = new HttpClient();
        _cache = memoryCache;
        
        // Set timeout for API calls
        _httpClient.Timeout = TimeSpan.FromSeconds(30);
    }    /// <summary>
    /// Generates a mask for an image, where transparent areas (alpha=0) can be edited
    /// and opaque white areas (alpha=255) should be preserved.
    /// </summary>
    /// <param name="imageStream">The image stream to generate a mask for</param>
    /// <param name="configOverrides">Optional dictionary of configuration overrides</param>
    /// <returns>A stream containing the generated mask as a PNG</returns>
    public async Task<Stream> GenerateMaskAsync(Stream imageStream, Dictionary<string, string>? configOverrides = null)
    {
        if (imageStream == null)
        {
            throw new ArgumentNullException(nameof(imageStream), "Image stream cannot be null");
        }

        _logger.LogInformation("Generating mask for image");

        // Reset stream position for reading
        if (imageStream.CanSeek)
        {
            imageStream.Position = 0;
        }
        
        // Generate a cache key based on image content hash and configuration overrides
        string cacheKey = GenerateCacheKey(imageStream, configOverrides);
        
        // Try to get mask from cache
        if (_cache.TryGetValue(cacheKey, out byte[]? cachedMaskData) && cachedMaskData != null)
        {
            _logger.LogInformation("Retrieved mask from cache");
            return new MemoryStream(cachedMaskData);
        }

        try
        {
            // Apply configuration overrides if provided
            IConfiguration effectiveConfig = _configuration;
            
            if (configOverrides != null && configOverrides.Count > 0)
            {
                // Create a new configuration source with the overrides
                var configBuilder = new ConfigurationBuilder();
                configBuilder.AddConfiguration(_configuration);
                configBuilder.AddInMemoryCollection(configOverrides);
                effectiveConfig = configBuilder.Build();
                
                _logger.LogInformation("Applied {Count} configuration overrides", configOverrides.Count);
            }
            
            // Check if SAM API is configured
            var samApiEndpoint = effectiveConfig["SAM:ApiEndpoint"];
            bool useSamApi = !string.IsNullOrEmpty(samApiEndpoint) && 
                             effectiveConfig.GetValue<bool>("SAM:Enabled", false);
            
            Stream maskStream;
            if (useSamApi)
            {
                _logger.LogInformation("Using SAM API for mask generation");
                
                // Check if multi-pass is enabled
                bool useMultiPass = effectiveConfig.GetValue<bool>("SAM:MultiPass", false);
                
                if (useMultiPass)
                {
                    maskStream = await GenerateMultiPassMaskAsync(imageStream, effectiveConfig);
                }
                else
                {
                    maskStream = await GenerateAdvancedSamMaskAsync(imageStream, effectiveConfig);
                }
            }
            else
            {
                _logger.LogInformation("SAM API not configured, using demo mask generation");
                maskStream = await GenerateDemoMaskAsync(imageStream);
            }
            
            // Cache the generated mask
            if (maskStream is MemoryStream ms)
            {
                _cache.Set(cacheKey, ms.ToArray(), TimeSpan.FromMinutes(30));
            }
            else
            {
                // If it's not a memory stream, copy it to one for caching
                var cachingMs = new MemoryStream();
                maskStream.Position = 0;
                await maskStream.CopyToAsync(cachingMs);
                _cache.Set(cacheKey, cachingMs.ToArray(), TimeSpan.FromMinutes(30));
                
                // Reset the position for the caller
                maskStream.Position = 0;
            }
              
            return maskStream;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error generating mask: {Message}", ex.Message);
            
            // Fall back to demo mask if there's an error
            _logger.LogWarning("Falling back to demo mask generation due to error");
            imageStream.Position = 0;
            return await GenerateDemoMaskAsync(imageStream);
        }
    }

    /// <summary>
    /// Creates a cache key based on the image content and configuration overrides
    /// </summary>
    private string GenerateCacheKey(Stream imageStream, Dictionary<string, string>? configOverrides = null)
    {
        // Save the current position
        long originalPosition = imageStream.Position;
        
        try
        {
            // Reset position for reading
            imageStream.Position = 0;
            
            // Compute a hash of the image data
            using var sha = System.Security.Cryptography.SHA256.Create();
            var hash = sha.ComputeHash(imageStream);
            string hashStr = BitConverter.ToString(hash).Replace("-", "");
            
            // If there are config overrides, include them in the cache key
            if (configOverrides != null && configOverrides.Count > 0)
            {
                // Sort the keys for consistency
                var sortedKeys = new List<string>(configOverrides.Keys);
                sortedKeys.Sort();
                
                // Add each key/value pair to the hash
                var configStr = new StringBuilder();
                foreach (var key in sortedKeys)
                {
                    configStr.Append($"{key}={configOverrides[key]};");
                }
                
                // Hash the config string
                var configHash = sha.ComputeHash(Encoding.UTF8.GetBytes(configStr.ToString()));
                string configHashStr = BitConverter.ToString(configHash).Replace("-", "");
                
                return $"mask_{hashStr}_{configHashStr}";
            }
            
            return $"mask_{hashStr}";
        }
        finally
        {
            // Restore original position
            imageStream.Position = originalPosition;
        }
    }

    /// <summary>
    /// Creates a demo mask for demonstration purposes.
    /// In a production app, this would be replaced with a real segmentation model.
    /// </summary>
    private async Task<Stream> GenerateDemoMaskAsync(Stream imageStream)
    {
        // We'll simulate a SAM-like segmentation model by:
        // 1. Loading the original image
        // 2. Creating a mask where the center 60% of the image is transparent (to be modified)
        // 3. And the outer 40% (walls, ceiling typically) is opaque white (to be preserved)
        
        try
        {
            // Create a memory stream to hold the mask
            var maskStream = new MemoryStream();

            // For demonstration, we'll use SkiaSharp to create a simple mask
            // with a clear center region (editable) and white border (preserved)
            using (var skBitmap = SkiaSharp.SKBitmap.Decode(imageStream))
            {
                if (skBitmap == null)
                {
                    throw new InvalidOperationException("Failed to decode input image for mask generation");
                }

                int width = skBitmap.Width;
                int height = skBitmap.Height;
                
                // Create a new bitmap with the same dimensions but RGBA format
                using var maskBitmap = new SkiaSharp.SKBitmap(width, height, SkiaSharp.SKColorType.Rgba8888, SkiaSharp.SKAlphaType.Premul);
                
                // Get usable canvas for the bitmap
                using var canvas = new SkiaSharp.SKCanvas(maskBitmap);
                
                // Fill the entire bitmap with white (preserved areas)
                canvas.Clear(SkiaSharp.SKColors.White);
                
                // Calculate the center area that should be transparent (editable)
                int centerX = width / 2;
                int centerY = height / 2;
                int centerWidth = (int)(width * 0.6f); // 60% of width is editable
                int centerHeight = (int)(height * 0.6f); // 60% of height is editable
                
                // Create transparent rectangle in the center
                using var paint = new SkiaSharp.SKPaint
                {
                    Color = new SkiaSharp.SKColor(255, 255, 255, 0), // Transparent
                    BlendMode = SkiaSharp.SKBlendMode.Clear
                };
                
                // Draw the transparent center area
                canvas.DrawRect(
                    centerX - (centerWidth / 2),
                    centerY - (centerHeight / 2),
                    centerWidth,
                    centerHeight,
                    paint
                );
                
                // Encode as PNG and save to the stream
                using var image = SkiaSharp.SKImage.FromBitmap(maskBitmap);
                using var data = image.Encode(SkiaSharp.SKEncodedImageFormat.Png, 100);
                await Task.Run(() => data.SaveTo(maskStream));
            }
            
            // Reset the position for reading
            maskStream.Position = 0;
            return maskStream;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error generating demo mask: {Message}", ex.Message);
            throw new InvalidOperationException($"Error generating demo mask: {ex.Message}", ex);
        }
    }    /// <summary>
    /// Generates a mask using the Segment Anything Model (SAM) via API integration with advanced filtering.
    /// This method calls a hosted SAM API endpoint to generate accurate segmentation masks with automatic
    /// class filtering, down-sizing optimization, and feathered edges.
    /// </summary>
    private async Task<Stream> GenerateAdvancedSamMaskAsync(Stream imageStream, IConfiguration configuration)
    {
        // Reset stream position
        imageStream.Position = 0;
        
        try
        {
            // Load original image to get dimensions
            using var originalImage = SkiaSharp.SKBitmap.Decode(imageStream);
            if (originalImage == null)
            {
                throw new InvalidOperationException("Failed to decode input image for mask generation");
            }

            int originalWidth = originalImage.Width;
            int originalHeight = originalImage.Height;
            
            _logger.LogInformation("Original image dimensions: {Width}x{Height}", originalWidth, originalHeight);

            // Optimize for SAM processing: down-size if needed
            Stream processImageStream;
            float scaleFactor = 1.0f;
            
            if (Math.Max(originalWidth, originalHeight) > OptimalSegmentationSize)
            {
                scaleFactor = (float)OptimalSegmentationSize / Math.Max(originalWidth, originalHeight);
                int scaledWidth = (int)(originalWidth * scaleFactor);
                int scaledHeight = (int)(originalHeight * scaleFactor);
                
                _logger.LogInformation("Down-sizing image for SAM processing: {ScaledWidth}x{ScaledHeight} (scale: {ScaleFactor:F2})", 
                    scaledWidth, scaledHeight, scaleFactor);
                
                processImageStream = ResizeImageStream(imageStream, scaledWidth, scaledHeight);
            }
            else
            {
                imageStream.Position = 0;
                processImageStream = imageStream;
            }

            // Convert processed image to base64
            byte[] imageBytes;
            using (var memoryStream = new MemoryStream())
            {
                await processImageStream.CopyToAsync(memoryStream);
                imageBytes = memoryStream.ToArray();
            }
            var base64Image = Convert.ToBase64String(imageBytes);

            // Get API configuration
            var apiEndpoint = configuration["SAM:ApiEndpoint"];
            var apiKey = configuration["SAM:ApiKey"];
            
            if (string.IsNullOrEmpty(apiEndpoint))
            {
                throw new InvalidOperationException("SAM API endpoint not configured");
            }
            
            // Create comprehensive request for automatic object detection
            var requestBody = new
            {
                image = base64Image,
                prompt = "Detect all objects and room elements for interior design editing",
                mode = "automatic", // Use automatic segmentation
                include_confidence = true, // Request confidence scores
                return_masks = true, // Get detailed masks
                classes = new[] 
                { 
                    // Furniture and editable items
                    "sofa", "chair", "table", "lamp", "cabinet", "rug", "curtain", "pillow",
                    "artwork", "painting", "mirror", "vase", "plant", "clock", "tv", "furniture",
                    
                    // Structural elements to preserve
                    "wall", "ceiling", "floor", "window", "door", "beam", "column", "molding",
                    "outlet", "switch", "vent", "radiator", "fireplace"
                },
                confidence_threshold = 0.5 // Lower threshold to catch more objects
            };
            
            // Send request to SAM API
            var maskData = await CallSamApiAsync(apiEndpoint, apiKey, requestBody);
            
            // Process response with advanced filtering
            var resultMask = await ProcessAdvancedSamResponseAsync(maskData, originalWidth, originalHeight, scaleFactor);
            
            // Apply feathering for ultra-clean edges
            var featheredMask = await ApplyFeatheringAsync(resultMask, originalWidth, originalHeight);
            
            return featheredMask;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error in advanced SAM mask generation: {Message}", ex.Message);
            throw new InvalidOperationException($"Error in advanced SAM mask generation: {ex.Message}", ex);
        }
        finally
        {
            // Clean up if we created a resized stream
            if (imageStream.Position != 0)
            {
                imageStream.Position = 0;
            }
        }
    }        {
            // Reset stream position
            imageStream.Position = 0;
            
            try
            {
                // Convert image stream to base64
                byte[] imageBytes;
                using (var memoryStream = new MemoryStream())
                {
                    await imageStream.CopyToAsync(memoryStream);
                    imageBytes = memoryStream.ToArray();
                }
                var base64Image = Convert.ToBase64String(imageBytes);
                  // Get API configuration
                var apiEndpoint = configuration["SAM:ApiEndpoint"];
                var apiKey = configuration["SAM:ApiKey"];
                
                if (string.IsNullOrEmpty(apiEndpoint))
                {
                    throw new InvalidOperationException("SAM API endpoint not configured");
                }
                
                // Create the request payload with categories to identify
                var requestBody = new
                {
                    image = base64Image,
                    prompt = "Segment furniture and room structure",
                    classes = new[] 
                    { 
                        "sofa", "chair", "table", "lamp", "cabinet", "rug", 
                        "wall", "ceiling", "floor", "window", "door" 
                    }
                };
                
                // Prepare the HTTP request
                var request = new HttpRequestMessage(HttpMethod.Post, apiEndpoint);
                
                // Add API key if provided
                if (!string.IsNullOrEmpty(apiKey))
                {
                    request.Headers.Add("Authorization", $"Bearer {apiKey}");
                }
                
                var content = new StringContent(
                    JsonSerializer.Serialize(requestBody),
                    Encoding.UTF8,
                    "application/json");
                    
                request.Content = content;
                
                // Send the request
                _logger.LogInformation("Sending request to SAM API endpoint: {Endpoint}", apiEndpoint);
                var response = await _httpClient.SendAsync(request);
                
                if (!response.IsSuccessStatusCode)
                {
                    var errorContent = await response.Content.ReadAsStringAsync();
                    _logger.LogError("SAM API error: {StatusCode}. Response: {ErrorContent}", 
                        response.StatusCode, errorContent);
                    throw new InvalidOperationException($"Failed to call SAM API: {response.StatusCode}");
                }
                
                // Process the response
                var responseContent = await response.Content.ReadAsStringAsync();
                _logger.LogInformation("Received SAM API response with length: {Length}", responseContent.Length);
                
                // Parse the response 
                return await ProcessSamResponseAsync(responseContent, imageStream);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error using SAM API: {Message}", ex.Message);
                throw new InvalidOperationException($"Error using SAM API: {ex.Message}", ex);
            }
        }
      /// <summary>
    /// Process the SAM API response with advanced automatic filtering and confidence scoring
    /// </summary>
    private async Task<Stream> ProcessAdvancedSamResponseAsync(string apiResponse, int originalWidth, int originalHeight, float scaleFactor)
    {
        try
        {
            var responseJson = JsonDocument.Parse(apiResponse).RootElement;
            
            // Create result mask bitmap
            using var maskBitmap = new SkiaSharp.SKBitmap(originalWidth, originalHeight, SkiaSharp.SKColorType.Rgba8888, SkiaSharp.SKAlphaType.Premul);
            using var canvas = new SkiaSharp.SKCanvas(maskBitmap);
            
            // Start with white background (all preserved)
            canvas.Clear(SkiaSharp.SKColors.White);
            
            // Create paint for transparent areas (editable)
            using var transparentPaint = new SkiaSharp.SKPaint
            {
                Color = new SkiaSharp.SKColor(255, 255, 255, 0),
                BlendMode = SkiaSharp.SKBlendMode.Clear
            };
            
            // Process segments with automatic filtering
            if (responseJson.TryGetProperty("segments", out var segments))
            {
                int processedSegments = 0;
                int editableSegments = 0;
                
                foreach (var segment in segments.EnumerateArray())
                {
                    processedSegments++;
                    
                    // Get segment properties
                    string segmentClass = segment.GetProperty("class").GetString() ?? "";
                    float confidence = segment.TryGetProperty("confidence", out var confProp) ? confProp.GetSingle() : 1.0f;
                    
                    // Apply automatic filtering with confidence-based decisions
                    var filterResult = AutomaticClassFilter(segmentClass, confidence);
                    
                    if (filterResult.IsEditable)
                    {
                        editableSegments++;
                        _logger.LogDebug("Making segment editable: {Class} (confidence: {Confidence:F2}, reason: {Reason})", 
                            segmentClass, confidence, filterResult.Reason);
                        
                        // Apply the segment mask
                        await ApplySegmentMaskAsync(segment, canvas, transparentPaint, scaleFactor);
                    }
                    else
                    {
                        _logger.LogDebug("Preserving segment: {Class} (confidence: {Confidence:F2}, reason: {Reason})", 
                            segmentClass, confidence, filterResult.Reason);
                    }
                }
                
                _logger.LogInformation("Processed {Total} segments, made {Editable} editable", processedSegments, editableSegments);
            }
            
            // Encode as PNG
            var resultStream = new MemoryStream();
            using var image = SkiaSharp.SKImage.FromBitmap(maskBitmap);
            using var data = image.Encode(SkiaSharp.SKEncodedImageFormat.Png, 100);
            await Task.Run(() => data.SaveTo(resultStream));
            
            resultStream.Position = 0;
            return resultStream;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error processing advanced SAM response: {Message}", ex.Message);
            throw;
        }
    }

    /// <summary>
    /// Process SAM response for category-specific masks
    /// </summary>
    private async Task<Stream> ProcessCategorySpecificResponseAsync(string apiResponse, int originalWidth, int originalHeight, 
        float scaleFactor, HashSet<string> targetCategories)
    {
        try
        {
            var responseJson = JsonDocument.Parse(apiResponse).RootElement;
            
            using var maskBitmap = new SkiaSharp.SKBitmap(originalWidth, originalHeight, SkiaSharp.SKColorType.Rgba8888, SkiaSharp.SKAlphaType.Premul);
            using var canvas = new SkiaSharp.SKCanvas(maskBitmap);
            
            // Start with white background (all preserved)
            canvas.Clear(SkiaSharp.SKColors.White);
            
            using var transparentPaint = new SkiaSharp.SKPaint
            {
                Color = new SkiaSharp.SKColor(255, 255, 255, 0),
                BlendMode = SkiaSharp.SKBlendMode.Clear
            };
            
            if (responseJson.TryGetProperty("segments", out var segments))
            {
                foreach (var segment in segments.EnumerateArray())
                {
                    string segmentClass = segment.GetProperty("class").GetString() ?? "";
                    float confidence = segment.TryGetProperty("confidence", out var confProp) ? confProp.GetSingle() : 1.0f;
                    
                    // Only process segments in target categories with sufficient confidence
                    if (IsTargetCategory(segmentClass, targetCategories) && confidence >= MediumConfidenceThreshold)
                    {
                        await ApplySegmentMaskAsync(segment, canvas, transparentPaint, scaleFactor);
                    }
                }
            }
            
            var resultStream = new MemoryStream();
            using var image = SkiaSharp.SKImage.FromBitmap(maskBitmap);
            using var data = image.Encode(SkiaSharp.SKEncodedImageFormat.Png, 100);
            await Task.Run(() => data.SaveTo(resultStream));
            
            resultStream.Position = 0;
            return resultStream;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error processing category-specific SAM response: {Message}", ex.Message);
            throw;
        }
    }

    /// <summary>
    /// Applies a segment mask to the canvas with proper scaling
    /// </summary>
    private async Task<Stream> ApplySegmentMaskAsync(JsonElement segment, SkiaSharp.SKCanvas canvas, SkiaSharp.SKPaint paint, float scaleFactor)
    {
        if (segment.TryGetProperty("mask", out var maskProperty))
        {
            // Handle base64 encoded mask
            string base64Mask = maskProperty.GetString() ?? "";
            if (!string.IsNullOrEmpty(base64Mask))
            {
                byte[] maskBytes = Convert.FromBase64String(base64Mask);
                using var segmentMask = SkiaSharp.SKBitmap.Decode(maskBytes);
                
                if (segmentMask != null)
                {
                    if (scaleFactor != 1.0f)
                    {
                        // Scale the mask back to original size
                        int scaledWidth = (int)(segmentMask.Width / scaleFactor);
                        int scaledHeight = (int)(segmentMask.Height / scaleFactor);
                        
                        using var scaledMask = segmentMask.Resize(new SkiaSharp.SKImageInfo(scaledWidth, scaledHeight), SkiaSharp.SKFilterQuality.High);
                        if (scaledMask != null)
                        {
                            canvas.DrawBitmap(scaledMask, 0, 0, paint);
                        }
                    }
                    else
                    {
                        canvas.DrawBitmap(segmentMask, 0, 0, paint);
                    }
                }
            }
        }
        else if (segment.TryGetProperty("points", out var pointsArray))
        {
            // Handle polygon points
            var points = new List<SkiaSharp.SKPoint>();
            
            foreach (var point in pointsArray.EnumerateArray())
            {
                float x = point.GetProperty("x").GetSingle();
                float y = point.GetProperty("y").GetSingle();
                
                // Scale points back to original size if needed
                if (scaleFactor != 1.0f)
                {
                    x /= scaleFactor;
                    y /= scaleFactor;
                }
                
                points.Add(new SkiaSharp.SKPoint(x, y));
            }
            
            if (points.Count > 2)
            {
                using var path = new SkiaSharp.SKPath();
                path.MoveTo(points[0]);
                for (int i = 1; i < points.Count; i++)
                {
                    path.LineTo(points[i]);
                }
                path.Close();
                
                canvas.DrawPath(path, paint);
            }
        }
        
        return null; // This method modifies the canvas directly
    }

    /// <summary>
    /// Automatic class filtering with confidence-based decisions
    /// </summary>
    private (bool IsEditable, string Reason) AutomaticClassFilter(string segmentClass, float confidence)
    {
        if (string.IsNullOrEmpty(segmentClass))
        {
            return (confidence >= MediumConfidenceThreshold, "Unknown object with medium+ confidence");
        }
        
        // High confidence structural elements are always preserved
        if (confidence >= HighConfidenceThreshold && IsStructuralElement(segmentClass))
        {
            return (false, "High confidence structural element");
        }
        
        // High confidence editable elements are always editable
        if (confidence >= HighConfidenceThreshold && IsEditableElement(segmentClass))
        {
            return (true, "High confidence editable element");
        }
        
        // Medium confidence - use stricter categorization
        if (confidence >= MediumConfidenceThreshold)
        {
            if (IsDefinitelyStructural(segmentClass))
            {
                return (false, "Medium confidence but definitely structural");
            }
            
            if (IsDefinitelyEditable(segmentClass))
            {
                return (true, "Medium confidence but definitely editable");
            }
        }
        
        // Low confidence - conservative approach (preserve by default)
        if (confidence < MediumConfidenceThreshold)
        {
            // Only make editable if it's obviously furniture
            if (IsObviousFurniture(segmentClass))
            {
                return (true, "Low confidence but obvious furniture");
            }
            
            return (false, "Low confidence - preserving conservatively");
        }
        
        // Default for medium confidence unknown objects - slightly favor editing
        return (true, "Medium confidence unknown object - defaulting to editable");
    }
      /// <summary>
    /// Enhanced analysis of segmentation results with automatic confidence-based filtering
    /// </summary>
    private bool IsEditableSegment(string segmentClass)
    {
        // This method is kept for backward compatibility
        return AutomaticClassFilter(segmentClass, MediumConfidenceThreshold).IsEditable;
    }

    private bool IsStructuralElement(string segmentClass)
    {
        return StructuralCategories.Contains(segmentClass) || 
               StructuralCategories.Any(cat => segmentClass.Contains(cat, StringComparison.OrdinalIgnoreCase));
    }

    private bool IsEditableElement(string segmentClass)
    {
        return EditableCategories.Contains(segmentClass) || 
               EditableCategories.Any(cat => segmentClass.Contains(cat, StringComparison.OrdinalIgnoreCase));
    }

    private bool IsDefinitelyStructural(string segmentClass)
    {
        var definiteStructural = new[] { "wall", "ceiling", "floor", "window", "door", "beam", "column" };
        return definiteStructural.Any(term => segmentClass.Contains(term, StringComparison.OrdinalIgnoreCase));
    }

    private bool IsDefinitelyEditable(string segmentClass)
    {
        var definiteEditable = new[] { "sofa", "chair", "table", "lamp", "rug", "painting", "furniture" };
        return definiteEditable.Any(term => segmentClass.Contains(term, StringComparison.OrdinalIgnoreCase));
    }

    private bool IsObviousFurniture(string segmentClass)
    {
        var obviousFurniture = new[] { "sofa", "couch", "chair", "table", "lamp", "cabinet", "furniture" };
        return obviousFurniture.Any(term => segmentClass.Contains(term, StringComparison.OrdinalIgnoreCase));
    }

    private bool IsTargetCategory(string segmentClass, HashSet<string> targetCategories)
    {
        return targetCategories.Contains(segmentClass) || 
               targetCategories.Any(cat => segmentClass.Contains(cat, StringComparison.OrdinalIgnoreCase));
    }

    /// <summary>
    /// Generates masks using multiple passes for different object categories.
    /// This allows for separate handling of furniture vs wall art for iterative design layers.
    /// </summary>
    private async Task<Stream> GenerateMultiPassMaskAsync(Stream imageStream, IConfiguration configuration)
    {
        _logger.LogInformation("Starting multi-pass mask generation");
        
        try
        {
            // Load original image to get dimensions
            imageStream.Position = 0;
            using var originalImage = SkiaSharp.SKBitmap.Decode(imageStream);
            if (originalImage == null)
            {
                throw new InvalidOperationException("Failed to decode input image for multi-pass mask generation");
            }

            int width = originalImage.Width;
            int height = originalImage.Height;
            
            // Pass 1: Generate mask for furniture and large decorative elements
            _logger.LogInformation("Pass 1: Generating furniture mask");
            var furnitureMask = await GenerateSpecificCategoryMaskAsync(imageStream, configuration, "furniture", EditableCategories);
            
            // Pass 2: Generate mask for wall art and small decorative elements
            _logger.LogInformation("Pass 2: Generating wall art mask");
            var wallArtMask = await GenerateSpecificCategoryMaskAsync(imageStream, configuration, "wall_art", WallArtCategories);
            
            // Combine the masks intelligently
            _logger.LogInformation("Combining multi-pass masks");
            var combinedMask = await CombineMasksAsync(furnitureMask, wallArtMask, width, height);
            
            // Apply feathering for ultra-clean edges
            var featheredMask = await ApplyFeatheringAsync(combinedMask, width, height);
            
            return featheredMask;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error in multi-pass mask generation: {Message}", ex.Message);
            
            // Fall back to single-pass generation
            _logger.LogWarning("Falling back to single-pass mask generation");
            return await GenerateAdvancedSamMaskAsync(imageStream, configuration);
        }
    }

    /// <summary>
    /// Generates a mask for a specific category of objects
    /// </summary>
    private async Task<Stream> GenerateSpecificCategoryMaskAsync(Stream imageStream, IConfiguration configuration, 
        string categoryName, HashSet<string> targetCategories)
    {
        imageStream.Position = 0;
        
        // Optimize image size for processing
        using var originalImage = SkiaSharp.SKBitmap.Decode(imageStream);
        int originalWidth = originalImage.Width;
        int originalHeight = originalImage.Height;
        
        Stream processImageStream;
        float scaleFactor = 1.0f;
        
        if (Math.Max(originalWidth, originalHeight) > OptimalSegmentationSize)
        {
            scaleFactor = (float)OptimalSegmentationSize / Math.Max(originalWidth, originalHeight);
            int scaledWidth = (int)(originalWidth * scaleFactor);
            int scaledHeight = (int)(originalHeight * scaleFactor);
            
            processImageStream = ResizeImageStream(imageStream, scaledWidth, scaledHeight);
        }
        else
        {
            imageStream.Position = 0;
            processImageStream = imageStream;
        }

        // Convert to base64
        byte[] imageBytes;
        using (var memoryStream = new MemoryStream())
        {
            await processImageStream.CopyToAsync(memoryStream);
            imageBytes = memoryStream.ToArray();
        }
        var base64Image = Convert.ToBase64String(imageBytes);

        // Create category-specific request
        var requestBody = new
        {
            image = base64Image,
            prompt = $"Detect {categoryName} objects for interior design editing",
            mode = "targeted",
            include_confidence = true,
            return_masks = true,
            classes = targetCategories.ToArray(),
            confidence_threshold = categoryName == "wall_art" ? 0.7f : 0.6f // Higher threshold for wall art
        };
        
        var apiEndpoint = configuration["SAM:ApiEndpoint"];
        var apiKey = configuration["SAM:ApiKey"];
        
        // Send request
        var maskData = await CallSamApiAsync(apiEndpoint, apiKey, requestBody);
        
        // Process with category-specific filtering
        return await ProcessCategorySpecificResponseAsync(maskData, originalWidth, originalHeight, scaleFactor, targetCategories);
    }

    /// <summary>
    /// Resizes an image stream to the specified dimensions
    /// </summary>
    private Stream ResizeImageStream(Stream originalStream, int newWidth, int newHeight)
    {
        originalStream.Position = 0;
        
        using var originalBitmap = SkiaSharp.SKBitmap.Decode(originalStream);
        if (originalBitmap == null)
        {
            throw new InvalidOperationException("Failed to decode image for resizing");
        }

        using var resizedBitmap = originalBitmap.Resize(new SkiaSharp.SKImageInfo(newWidth, newHeight), SkiaSharp.SKFilterQuality.High);
        if (resizedBitmap == null)
        {
            throw new InvalidOperationException("Failed to resize image");
        }

        var resizedStream = new MemoryStream();
        using var image = SkiaSharp.SKImage.FromBitmap(resizedBitmap);
        using var data = image.Encode(SkiaSharp.SKEncodedImageFormat.Png, 90);
        data.SaveTo(resizedStream);
        
        resizedStream.Position = 0;
        return resizedStream;
    }

    /// <summary>
    /// Applies feathering to mask edges using Gaussian blur and thresholding for ultra-clean results
    /// </summary>
    private async Task<Stream> ApplyFeatheringAsync(Stream maskStream, int width, int height)
    {
        try
        {
            maskStream.Position = 0;
            
            using var maskBitmap = SkiaSharp.SKBitmap.Decode(maskStream);
            if (maskBitmap == null)
            {
                _logger.LogWarning("Failed to decode mask for feathering, returning original");
                maskStream.Position = 0;
                return maskStream;
            }

            // Create a new bitmap for the feathered result
            using var featheredBitmap = new SkiaSharp.SKBitmap(width, height, SkiaSharp.SKColorType.Rgba8888, SkiaSharp.SKAlphaType.Premul);
            using var canvas = new SkiaSharp.SKCanvas(featheredBitmap);
            
            // Apply Gaussian blur (2-3 pixels as recommended)
            using var blurPaint = new SkiaSharp.SKPaint
            {
                ImageFilter = SkiaSharp.SKImageFilter.CreateBlur(2.5f, 2.5f)
            };
            
            // Draw the original mask with blur
            canvas.DrawBitmap(maskBitmap, 0, 0, blurPaint);
            
            // Now threshold back to binary
            await Task.Run(() =>
            {
                var pixels = featheredBitmap.Pixels;
                for (int i = 0; i < pixels.Length; i++)
                {
                    var pixel = pixels[i];
                    // Extract alpha channel
                    byte alpha = pixel.Alpha;
                    
                    // Apply threshold: if alpha > 128, make it fully opaque (255), otherwise transparent (0)
                    byte newAlpha = alpha > 128 ? (byte)255 : (byte)0;
                    
                    // Create new pixel with thresholded alpha
                    if (newAlpha == 0)
                    {
                        pixels[i] = new SkiaSharp.SKColor(255, 255, 255, 0); // Transparent (editable)
                    }
                    else
                    {
                        pixels[i] = new SkiaSharp.SKColor(255, 255, 255, 255); // White opaque (preserved)
                    }
                }
                featheredBitmap.Pixels = pixels;
            });
            
            // Encode the result
            var resultStream = new MemoryStream();
            using var image = SkiaSharp.SKImage.FromBitmap(featheredBitmap);
            using var data = image.Encode(SkiaSharp.SKEncodedImageFormat.Png, 100);
            await Task.Run(() => data.SaveTo(resultStream));
            
            resultStream.Position = 0;
            _logger.LogInformation("Applied feathering with 2.5px Gaussian blur and binary threshold");
            return resultStream;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error applying feathering: {Message}", ex.Message);
            maskStream.Position = 0;
            return maskStream;
        }
    }

    /// <summary>
    /// Combines multiple mask streams intelligently
    /// </summary>
    private async Task<Stream> CombineMasksAsync(Stream mask1, Stream mask2, int width, int height)
    {
        try
        {
            mask1.Position = 0;
            mask2.Position = 0;
            
            using var bitmap1 = SkiaSharp.SKBitmap.Decode(mask1);
            using var bitmap2 = SkiaSharp.SKBitmap.Decode(mask2);
            
            if (bitmap1 == null || bitmap2 == null)
            {
                _logger.LogWarning("Failed to decode one or both masks for combining");
                return mask1.Length > mask2.Length ? mask1 : mask2;
            }

            // Create combined bitmap
            using var combinedBitmap = new SkiaSharp.SKBitmap(width, height, SkiaSharp.SKColorType.Rgba8888, SkiaSharp.SKAlphaType.Premul);
            using var canvas = new SkiaSharp.SKCanvas(combinedBitmap);
            
            // Start with white background (all preserved)
            canvas.Clear(SkiaSharp.SKColors.White);
            
            // Use multiply blend mode to combine masks (transparent areas in either mask become transparent)
            using var paint = new SkiaSharp.SKPaint
            {
                BlendMode = SkiaSharp.SKBlendMode.Multiply
            };
            
            // Draw both masks
            canvas.DrawBitmap(bitmap1, 0, 0, paint);
            canvas.DrawBitmap(bitmap2, 0, 0, paint);
            
            // Encode result
            var resultStream = new MemoryStream();
            using var image = SkiaSharp.SKImage.FromBitmap(combinedBitmap);
            using var data = image.Encode(SkiaSharp.SKEncodedImageFormat.Png, 100);
            await Task.Run(() => data.SaveTo(resultStream));
            
            resultStream.Position = 0;
            return resultStream;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error combining masks: {Message}", ex.Message);
            return mask1;
        }
    }

    /// <summary>
    /// Calls the SAM API with the given request body
    /// </summary>
    private async Task<string> CallSamApiAsync(string apiEndpoint, string? apiKey, object requestBody)
    {
        var request = new HttpRequestMessage(HttpMethod.Post, apiEndpoint);
        
        // Add API key if provided
        if (!string.IsNullOrEmpty(apiKey))
        {
            request.Headers.Add("Authorization", $"Bearer {apiKey}");
        }
        
        var content = new StringContent(
            JsonSerializer.Serialize(requestBody),
            Encoding.UTF8,
            "application/json");
            
        request.Content = content;
        
        // Send the request
        _logger.LogInformation("Sending request to SAM API endpoint: {Endpoint}", apiEndpoint);
        var response = await _httpClient.SendAsync(request);
        
        if (!response.IsSuccessStatusCode)
        {
            var errorContent = await response.Content.ReadAsStringAsync();
            _logger.LogError("SAM API error: {StatusCode}. Response: {ErrorContent}", 
                response.StatusCode, errorContent);
            throw new InvalidOperationException($"Failed to call SAM API: {response.StatusCode}");
        }
        
        var responseContent = await response.Content.ReadAsStringAsync();
        _logger.LogInformation("Received SAM API response with length: {Length}", responseContent.Length);
        
        return responseContent;
    }
}
